<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
		<title>XYZ Maps Example: Crossing test </title>
	   	<script src="${XYZ_COMMON_PATH}" type="text/javascript" charset="UTF-8" ></script>
	    <script src="${XYZ_CORE_PATH}" type="text/javascript" charset="UTF-8" ></script>
	    <script src="${XYZ_DISPLAY_PATH}" type="text/javascript" charset="UTF-8" ></script>
	    <script src="${XYZ_EDITOR_PATH}" type="text/javascript" charset="UTF-8" ></script>

		<style type="text/css">
			#map {
				position: absolute;
            	overflow: hidden;
				top: 0;
				left: 0;
				width: 100%;
                height: 100%;
			}
		</style>
	</head>
	<body>
		<div id="map"></div>
		<a id="crossing" class="button">Show Crossing</a>
		<script type="application/javascript">
	      	var YOUR_ACCESS_TOKEN = window.parent.YOUR_ACCESS_TOKEN;

			// Define customized Provider that extends from SpaceProvider
			class MyProvider extends here.xyz.maps.providers.SpaceProvider {

				// detect feature class by "featureClass" in feature's properties
				detectFeatureClass(feature) {
					return feature.properties.featureClass;
				}

				// read routing point value from Address or Place property
				// implementing this function is necessary only if there were Address or Place in Space
				readRoutingPosition(feature) {
					return feature.prop('routingPoint');
				}

				// read id of routing link from Address or Place property
				// implementing this function is necessary only if there were Address or Place in Space
				readRoutingLink(feature) {
					return feature.prop('routingLink');
				}

				// write routing point to Address or Place
				// implementing this function is necessary only if there were Address or Place in Space
				writeRoutingPosition(feature, position) {
					feature.prop('routingPoint', position);
				}

				// write id of routing link to Address or Place
				// implementing this function is necessary only if there were Address or Place in Space
				writeRoutingLink(feature, link) {
					feature.prop('routingLink', link ? link.id : link);
				}

				// read turn restriction value from Link property
				// implementing this function is necessary only if there was Link in Space
				readTurnRestriction(from, to) {
					let turn = from.link.prop('turnRestriction') || {};
					// first shape point is 'start' and the last one is 'end'
					let restrictions = turn[from.index ? 'end' : 'start'] || [];

					// check if the id of to-link is already restricted
					return restrictions.indexOf(to.link.id) >= 0;
				};

				// edit turn restriction value on Link
				// implementing this function is necessary only if there was Link in Space
				writeTurnRestriction(restricted, from, to) {
					let turn = from.link.prop('turnRestriction') || {};
					let node = from.index ? 'end' : 'start';
					let restrictions = turn[node] = turn[node] || [];
					let index = restrictions.indexOf(to.link.id);

					if (restricted) {
						if (index == -1) {
							// add id of to-link to restrictions array
							restrictions.push(to.link.id);
						}
					} else if (index >= 0) {
						// remove the id out of restrictions array if the link was restricted
						restrictions.splice(index, 1);
					}

					// set turnRestriction to from-link
					from.link.prop('turnRestriction', turn);
				}

				// read if the Link is pedestrian only
				// implementing this function is necessary only if there was Link in Space
				readPedestrianOnly(feature) {
					return Boolean(feature.prop('pedestrianOnly'));
				}

				// read the direction value on Link, expected values are: 'BOTH', 'START_TO_END' or 'END_TO_START'
				// implementing this function is necessary only if there was Link in Space
				readDirection(feature) {
					return feature.prop('direction') || 'BOTH';
				}

				// Address or Place connects to a Link with its 'routingLink' and 'routingPoint' properties,
				// the connected Link could be either in the same space as the Address or Place is or in a different space,
				// this function returns id of provider which contains space of the connected Link
				readRoutingProvider(location, providers) {
					for (let provider of providers) {
						// id of link provider should have keyword 'link'
						if (provider.id.toLowerCase().indexOf('link') >= 0) {
							return provider.id;
						}
					}
				}
			}

			var bgLayer = new here.xyz.maps.layers.MVTLayer({
				name: 'background layer',
				min: 1,
				max: 20,
				remote: {
					url: 'https://xyz.api.here.com/tiles/osmbase/256/all/{z}/{x}/{y}.mvt?access_token='+YOUR_ACCESS_TOKEN
				}
			});
			var linkLayer = new here.xyz.maps.layers.TileLayer({
				name: 'Link Layer',
				min: 14,
				max: 20,
				// Customized provider to provide objects
				provider: new MyProvider({
					id: "linkProvider",
					space: "playground-link",
					credentials: {
						access_token: YOUR_ACCESS_TOKEN
					},
					level: 14
				})
			});

	        // setup the Map Display
			window.display = new  here.xyz.maps.Map( document.getElementById("map"), {
	                zoomLevel : 17,
					center : { longitude: 76.30475, latitude: 9.97585 },

	                // add layers to display
	                layers: [bgLayer, linkLayer]
	            });

			// setup the editEngine
	        var editor = new here.xyz.maps.editor.Editor( display );

			// add link layer to editor, make layers editable
			editor.addLayer( linkLayer );


/*###visiblesource*/
var crossings = [];

/**
 * Click button to add a link and show crossings with this ink
 */
document.querySelector("#crossing").onclick = function(){
	// clear existing crossings
	for( var i in crossings )
		crossings[i].hide();


	var width = display.getWidth();
	var height = display.getHeight();
	var pointspixel = [
		new here.xyz.maps.editor.PixelCoordinate(width * Math.random() , height * Math.random()),
		new here.xyz.maps.editor.PixelCoordinate(width * Math.random() , height * Math.random())
	];

	// add link to editor
	var lnk = editor.addFeature( new here.xyz.maps.editor.features.Navlink(pointspixel, {featureClass: 'NAVLINK'}) );

	//detect and get the array of crossings and crossing candidates
	crossings = lnk.checkCrossings();

	//show the crossings and crossing candidates on the map
	for( var i in crossings )
		crossings[i].show();
}

editor.addEventListener('pointerup', function(event) {
	// leftclick!
	if(event.button == 0) {
		var object = event.target;

		if(object && object.class.indexOf("CROSSING")>-1) {
			//ask the user if the crossing should become connected
			var usersChoice = confirm('Do you want to connect this '+object.class+
						' between link: '+object.getLink().id+
						' and link: '+object.getRelatedLink().id+'?');

			if(usersChoice){
				//if the user's choice was "yes", connect the crossing and update/refresh the other crossings
				//because the link shape could be changed
				object.connect();

				//refresh the crossings and crossing candidates on the map
				for(var i=0; i<crossings.length; i++){
					crossings[i].show();
				}
			} else {
				//if the user's choice was "no", hide the selected crossing or crossing candidate
				object.hide();
			}
		}
	}
});
/*visiblesource###*/
		</script>
	</body>
</html>
